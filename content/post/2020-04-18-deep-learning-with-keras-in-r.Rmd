---
title: Deep Learning With Keras in R
author: ZERO
date: '2020-04-18'
slug: deep-learning-with-keras-in-r
categories:
  - Tools
tags:
  - Deep Learning
subtitle: ''
summary: ''
authors: []
lastmod: '2020-04-18T09:53:53+08:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(
	eval = FALSE,
	echo = TRUE,
	message = FALSE,
	warning = FALSE,
	include = FALSE
)
  # Toggle off warning output
knitr::opts_knit$set(root.dir = usethis::proj_path())
library(docknitr)

library(tidyverse)
theme_set(theme_light())
```

```{sh}
# 1 
ssh -L 4321:localhost:4321 -L 8100:localhost:8100 -p 37482 jixing@241q703q35.wicp.vip

tmux a -t rstudio

# 2 cd path

# 3 run R
/home/jixing/anaconda3/bin/R

# 4 run rmote
# devtools::install_github(c("yihui/servr", "hafen/rmote"))
rmote::start_rmote()


```


## Load Libraries

```{r}
# pkgs <- c("keras", "lime", "tidyquant", "rsample", "recipes", "yardstick", "corrr")
# install.packages(pkgs)

# Load libraries
library(keras)
library(lime)
library(tidyquant)
library(rsample)
library(recipes)
library(yardstick)
library(corrr)
library(readr)
library(ggplot2)
library(forcats)
theme_set(theme_light())


```

## Import Data

Download the[IBM Watson Telco Data Set here](https://www.ibm.com/communities/analytics/watson-analytics-blog/predictive-insights-in-the-telco-customer-churn-data-set/). Next, use`read_csv()`to import the data into a nice tidy data frame. We use the`glimpse()`function to quickly inspect the data. We have the target "Churn" and all other variables are potential predictors. The raw data set needs to be cleaned and preprocessed for ML.


```{r}
# kaggle

churn_data_raw <- read_csv("WA_Fn-UseC_-Telco-Customer-Churn.csv")

glimpse(churn_data_raw)
```

Use sapply to check the number if missing values in each columns

```{r}
sapply(churn_data_raw, function(x) sum(is.na(x)))
```

## 📌  Preprocess Data

> We'll go through a few steps to preprocess the data for ML. First, we "prune" the data, which is nothing more than removing unnecessary columns and rows. Then we split into training and testing sets. After that we explore the training set to uncover transformations that will be needed for deep learning. We save the best for last. We end by preprocessing the data with the new [recipes](https://topepo.github.io/recipes) package.

+ prune: 去掉不要的行和列
+ split: 切分数据
+ EDA explore the data


### Prune The Data

The data has a few columns and rows we'd like to remove:

  * The "customerID" column is a unique identifier for each observation that isn't needed for modeling. We can de-select this column.
  * The data has 11 `NA` values all in the "TotalCharges" column. Because it's such a small percentage of the total population (99.8% complete cases), we can drop these observations with the `drop_na()` function from [tidyr](http://tidyr.tidyverse.org/). Note that these may be customers that have not yet been charged, and therefore an alternative is to replace with zero or -99 to segregate this population from the rest.
  * My preference is to have the target in the first column so we'll include a final select() ooperation to do so.

We'll perform the cleaning operation with one tidyverse pipe (%>%) chain.

```{r}
# remove unnecessary data
churn_data_tbl <-
  churn_data_raw %>%
  select(-customerID) %>%
  drop_na() %>%
  select(Churn, everything())

glimpse(churn_data_tbl)
```

Bar plots of categorical variables
```{r}
p1 <- ggplot(churn_data_tbl, aes(x=gender)) + ggtitle("Gender") + xlab("Gender") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip()
p2 <- ggplot(churn_data_tbl, aes(x=SeniorCitizen)) + ggtitle("Senior Citizen") + xlab("Senior Citizen") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p3 <- ggplot(churn_data_tbl, aes(x=Partner)) + ggtitle("Partner") + xlab("Partner") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip()
p4 <- ggplot(churn_data_tbl, aes(x=Dependents)) + ggtitle("Dependents") + xlab("Dependents") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip()

library(gridExtra)
library(grid)
library(ggplot2)
library(lattice)
p5 <- ggplot(churn_data_tbl, aes(x=PhoneService)) + ggtitle("Phone Service") + xlab("Phone Service") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p6 <- ggplot(churn_data_tbl, aes(x=MultipleLines)) + ggtitle("Multiple Lines") + xlab("Multiple Lines") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p7 <- ggplot(churn_data_tbl, aes(x=InternetService)) + ggtitle("Internet Service") + xlab("Internet Service") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p8 <- ggplot(churn_data_tbl, aes(x=OnlineSecurity)) + ggtitle("Online Security") + xlab("Online Security") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p9 <- ggplot(churn_data_tbl, aes(x=OnlineBackup)) + ggtitle("Online Backup") + xlab("Online Backup") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip()
p10 <- ggplot(churn_data_tbl, aes(x=DeviceProtection)) + ggtitle("Device Protection") + xlab("Device Protection") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p11 <- ggplot(churn_data_tbl, aes(x=TechSupport)) + ggtitle("Tech Support") + xlab("Tech Support") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p12 <- ggplot(churn_data_tbl, aes(x=StreamingTV)) + ggtitle("Streaming TV") + xlab("Streaming TV") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() 
p13 <- ggplot(churn_data_tbl, aes(x=StreamingMovies)) + ggtitle("Streaming Movies") + xlab("Streaming Movies") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() + theme_minimal()
p14 <- ggplot(churn_data_tbl, aes(x=Contract)) + ggtitle("Contract") + xlab("Contract") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() + theme_minimal()
p15 <- ggplot(churn_data_tbl, aes(x=PaperlessBilling)) + ggtitle("Paperless Billing") + xlab("Paperless Billing") + 
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() + theme_minimal()
p16 <- ggplot(churn_data_tbl, aes(x=PaymentMethod)) + ggtitle("Payment Method") + xlab("Payment Method") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() + theme_minimal()
p17 <- ggplot(churn_data_tbl, aes(x=tenure)) + ggtitle("Tenure Group") + xlab("Tenure Group") +
  geom_bar(aes(y = 100*(..count..)/sum(..count..)), width = 0.5) + ylab("Percentage") + coord_flip() + theme_minimal()

grid.arrange(p1, p2, p3, p4, ncol=2)
grid.arrange(p5, p6, p7, p8, ncol=2)
grid.arrange(p9, p10, p11, p12, ncol=2)
grid.arrange(p13, p14, p15, p16, p17, ncol=2)
```

### Split Into Train/Test Sets

We have a new package, [rsample](https://topepo.github.io/rsample/), which is very useful for sampling methods. It has the `initial_split()` function for splitting data sets into training and testing sets. The return is a special `rsplit` object.
    
```{r}
# Split test/training sets
set.seed(100)
train_test_split <- initial_split(churn_data_tbl, prop = 0.8)
train_test_split

# Retrieve train and test sets
train_tbl <- training(train_test_split)
test_tbl  <- testing(train_test_split)
```


### Exploration: What Transformation Steps Are Needed For ML?

This phase of the analysis is often called exploratory analysis, but basically **we are trying to answer the question, "What steps are needed to prepare for ML?" The key concept is knowing what transformations are needed to run the algorithm most effectively**. <font color="darkred"> __Artificial Neural Networks are best when the data is one-hot encoded, scaled and centered__</font> . In addition, other transformations may be beneficial as well to make relationships easier for the algorithm to identify. A full exploratory analysis is not practical in this article. With that said we'll cover a few tips on transformations that can help as they relate to this dataset. In the next section, we will implement the preprocessing techniques.

回答一个问题: ML 需要什么样的数据? 数据需要做什么样的转换.

> <font color="darkred">one-hot, scaled and centered</font> 比较适合神经网络



#### Discretize The "tenure" Feature

Numeric features like age, years worked, length of time in a position can generalize a group (or <font color="darkred"> __cohort__</font> ). We see this in marketing a lot (think "millennials", which identifies a group born in a certain timeframe). The "tenure" feature falls into this category of numeric features that can be discretized into groups.

连续变量的离散化

```{r}
library(ggplot2)
churn_data_tbl %>% 
  ggplot() +
  geom_histogram(aes(tenure), bins = "6") +
  tidyquant::theme_tq()
```



#### Transform The "totalcharges" Feature

log transform 

What we don't like to see is when a lot of observations are bunched within a small part of the range.

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-11-1.png)

__We can use a log transformation to even out the data into more of a normal distribution.__ It's not perfect, but it's quick and easy to get our data spread out a bit more.

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-12-1.png)


#### 数据转换改变数据之间的相关性

**Pro Tip: A quick test is to see if the log transformation increases the magnitude of the correlation** between "TotalCharges" and "Churn". We'll use a few [dplyr](http://dplyr.tidyverse.org/) operations along with the [corrr](https://github.com/drsimonj/corrr) package to perform a quick correlation.

  * `correlate()`: Performs tidy correlations on numeric data
  * `focus()`: Similar to `select()`. Takes columns and focuses on only the rows/columns of importance.
  * `fashion()`: Makes the formatting aesthetically easier to read.

```{r}
# Determine if log transformation improves correlation 
# between TotalCharges and Churn
train_tbl %>%
  select(Churn, TotalCharges) %>%
  mutate(
      Churn = Churn %>% as.factor() %>% as.numeric(),
      LogTotalCharges = log(TotalCharges)
      ) %>%
  correlate() %>%
  focus(Churn) %>%
  fashion()
```

The correlation between "Churn" and "LogTotalCharges" is greatest in magnitude indicating the __log transformation should improve the accuracy of the ANN model__ we build. Therefore, we should perform the log transformation.

x 和 y 之间的相关性, 经过转换后增强了, 这样有利于模型的训练


#### One-Hot Encoding

One-hot encoding is the process of __converting categorical data to sparse data__, which has columns of only zeros and ones (this is also called creating "dummy variables" or a "design matrix"). __All non-numeric data will need to be converted to dummy variables__. This is simple for binary Yes/No data because we can simply convert to 1's and 0's. It becomes slightly more complicated with multiple categories, which requires creating new columns of 1's and 0`s for each category (actually one less). __We have four features that are multi-category: Contract, Internet Service, Multiple Lines, and Payment Method.__

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-14-1.png)

#### Feature Scaling

ANN's typically perform faster and often times with higher accuracy when the features are scaled and/or normalized (aka centered and scaled, also known as __standardizing__). __Because ANNs use gradient descent, weights tend to update faster__. According to [_Sebastian Raschka_](https://sebastianraschka.com/), an expert in the field of Deep Learning, several examples when feature scaling is important are:

>   * k-nearest neighbors with an Euclidean distance measure if want all features to contribute equally
>   * k-means (see k-nearest neighbors)
>   * logistic regression, SVMs, perceptrons, neural networks etc. if you are using gradient descent/ascent-based optimization, otherwise some weights will update much faster than others
>   * linear discriminant analysis, principal component analysis, kernel principal component analysis since you want to find directions of maximizing the variance (under the constraints that those directions/eigenvectors/principal components are orthogonal); __you want to have features on the same scale since you'd emphasize variables on "larger measurement scales" more__. There are many more cases than I can possibly list here … I always recommend you to think about the algorithm and what it's doing, and then it typically becomes obvious whether we want to scale your features or not.

The interested reader can read [Sebastian Raschka's article](http://sebastianraschka.com/Articles/2014_about_feature_scaling.html) for a full discussion on the scaling/normalization topic. <font color="darkred"> __Pro Tip: When in doubt, standardize the data__</font>.


### Preprocessing With Recipes

Let's implement the preprocessing steps/transformations uncovered during our exploration. Max Kuhn (creator of [caret](http://topepo.github.io/caret/index.html)) has been putting some work into _Rlang ML tools_ lately, and the payoff is beginning to take shape. **A new package, [recipes](https://topepo.github.io/recipes), makes creating ML data preprocessing workflows a breeze**! It takes a little getting used to, but I've found that it really helps manage the preprocessing steps. We'll go over the nitty gritty as it applies to this problem.


#### Step 1: Create A Recipe

__A "recipe" is nothing more than a series of steps you would like to perform on the training, testing and/or validation sets__. Think of preprocessing data like baking a cake (I'm not a baker but stay with me). __The recipe is our steps to make the cake__. It doesn't do anything other than create the playbook for baking.

We use the `recipe()` function to implement our preprocessing steps. The function takes a familiar `object` argument, which is a modeling function such as `object = Churn ~ .` meaning "Churn" is the outcome (aka response, predictor, target) and all other features are predictors. The function also takes the `data` argument, which gives the "recipe steps" perspective on how to apply during baking (next).

A recipe is not very useful until we add "steps", which are used to transform the data during baking. The package contains a number of useful "step functions" that can be applied. The entire list of [Step Functions](https://topepo.github.io/recipes/reference/index.html) can be viewed here. For our model, we use:

  1. `step_discretize()` with the `option = list(cuts = 6)` to cut the continuous variable for "tenure" (number of years as a customer) to group customers into cohorts. 数据离散化
  2. `step_log()` to log transform "TotalCharges".
  3. `step_dummy()` to one-hot encode the categorical data. Note that this adds columns of one/zero for categorical data with three or more categories.
  4. `step_center()` to mean-center the data. 所有数据减去平均值
  5. `step_scale()` to scale the data.

The last step is to prepare the recipe with the `prep()` function. This step is used to "estimate the required parameters from a training set that can later be applied to other data sets". __This is important for centering and scaling and other functions that use parameters defined from the training set__.

`prep()`, 这一步非常重要, 可以评估需要的参数保存下来用于之后的 future raw data, 这对于数据标准化这一步是非常重要的. 


**Here's how simple it is to implement the preprocessing steps that we went over!**

```{r}
# Create recipe
rec_obj <-
  recipe(Churn ~ ., data = train_tbl) %>%
  step_discretize(tenure, options = list(cuts = 6)) %>% # cut to 6 bins
  step_log(TotalCharges) %>%
  step_dummy(all_nominal(), -all_outcomes()) %>%
  step_center(all_predictors(), -all_outcomes()) %>%
  step_scale(all_predictors(), -all_outcomes()) %>%
  prep(data = train_tbl)
```


We can print the recipe object if we ever forget what steps were used to prepare the data. **Pro Tip: We can save the recipe object as an RDS file using `saveRDS()`, and then use it to `bake()` (discussed next) future raw data into ML-ready data in production!**

我们可以保存下来这个 recipes 用于之后的数据准备, 这对于使用模型预测数据是非常重要的.

```{r}
# Print the recipe object
rec_obj
```

#### Step 2: Baking With Your Recipe

Now for the fun part! We can apply the "recipe" to any data set with the `bake()` function, and it processes the data following our recipe steps. We'll apply to our training and testing data to convert from raw data to a machine learning dataset. Check our training set out with `glimpse()`. **Now that's an ML-ready dataset prepared for ANN modeling!!**


<font color="darkred">raw dataset to machine learning dataset</font> 

```{r}
# Predictors
x_train_tbl <- bake(rec_obj, new_data = train_tbl) %>% select(-Churn)
x_test_tbl  <- bake(rec_obj, new_data = test_tbl) %>% select(-Churn)

glimpse(x_train_tbl)
```

#### Step 3: Don't Forget The Target

One last step, we need to store the actual values (truth) as `y_train_vec` and `y_test_vec`, which are needed for modeling our ANN. We convert to a series of numeric ones and zeros which can be accepted by the Keras ANN modeling functions. We add "vec" to the name so we can easily remember the class of the object (it's easy to get confused when working with tibbles, vectors, and matrix data types).

```{r}
    
# Response variables for training and testing sets
y_train_vec <- ifelse(pull(train_tbl, Churn) == "Yes", 1, 0)
y_test_vec  <- ifelse(pull(test_tbl, Churn) == "Yes", 1, 0)

```

## 📌 Keras: Model Customer Churn With Keras (Deep Learning)

**This is super exciting!! Finally, Deep Learning with Keras in R!** The team at RStudio has done fantastic work recently to create the [keras](https://tensorflow.rstudio.com/keras/) package, which implements [Keras](https://keras.io/) in R. Very cool!

### Background On Artifical Neural Networks

For those unfamiliar with Neural Networks (and those that need a refresher), [read this article](https://www.xenonstack.com/blog/overview-of-artificial-neural-networks-and-its-applications). It's very comprehensive, and you'll leave with a general understanding of the types of deep learning and how they work.

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/Artificial-Neural-Network-Architecture.jpg)

Source: [Xenon Stack](https://www.xenonstack.com/blog/overview-of-artificial-neural-networks-and-its-applications)

Deep Learning has been available in R for some time, but the primary packages used in the wild have not (this includes Keras, Tensor Flow, Theano, etc, which are all Python libraries). It's worth mentioning that a number of other Deep Learning packages exist in R including `h2o`, `mxnet`, and others. The interested reader can check out [this blog post for a comparison of deep learning packages in R](http://www.rblog.uni-freiburg.de/2017/02/07/deep-learning-in-r/).


### Building A Deep Learning Model

We're going to build a special class of ANN called a [Multi-Layer Perceptron (MLP)](https://en.wikipedia.org/wiki/Multilayer_perceptron). MLPs are one of the simplest forms of deep learning, but they are both highly accurate and serve as a jumping-off point for more complex algorithms. MLPs are quite versatile as they can be used for regression, binary and multi classification (and are typically quite good at classification problems).

We'll build a three layer MLP with Keras. Let's walk-through the steps before we implement in R.

  1. <font color="darkred">**Initialize a sequential model**</font> : The first step is to initialize a sequential model with `keras_model_sequential()`, which is the beginning of our Keras model. The sequential model is composed of a linear stack of layers.

  2. **Apply layers to the sequential model**: Layers consist of the input layer, hidden layers and an output layer. The __input layer is the data and provided it's formatted correctly there's nothing more to discuss__. The hidden layers and output layers are what controls the ANN inner workings.


  * **Hidden Layers**: Hidden layers form the neural network nodes that enable non-linear activation using weights. The hidden layers are created using `layer_dense()`. We'll add two hidden layers. We'll apply `units = 16`, which is the __number of nodes__. We'll select `kernel_initializer = "uniform"` and `activation = "relu"` for both layers. The first layer needs to have the `input_shape = 35`, which is the number of columns in the training set (the number of feature) . **Key Point: While we are arbitrarily selecting the number of hidden layers, units, kernel initializers and activation functions, these parameters can be optimized through a process called hyperparameter tuning that is discussed in [Next Steps](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/#next-steps)**.

> 关键点：尽管我们可以任意选择隐藏层，单元，内核初始化程序和激活函数的数量，但是可以通过称为"超参数调整"的过程来优化这些参数，该过程将在[后续步骤]中进行讨论。

  * **Dropout Layers**: Dropout layers are used to __control overfitting__. This eliminates weights below a cutoff threshold to prevent low weights from overfitting the layers. We use the `layer_dropout()` function add two drop out layers with `rate = 0.10` to remove weights below 10%.
  

  * **Output Layer**: The output layer specifies the shape of the output and the method of assimilating the learned information. The output layer is applied using the `layer_dense()`. For binary values, the shape should be `units = 1`. For multi-classification, the `units` should correspond to the number of classes. We set the `kernel_initializer = "uniform"` and the `activation = "sigmoid"` (common for binary classification).

  3. **Compile the model**: The last step is to compile the model with `compile()`. We'll use `optimizer = "adam"`, which is one of the most popular optimization algorithms. We select `loss = "binary_crossentropy"` since this is a binary classification problem. We'll select `metrics = c("accuracy")` to be evaluated during training and testing. **Key Point: The optimizer is often included in the tuning process**.


#### Build model object
Let's codify the discussion above to build our Keras MLP-flavored ANN model.

```{r}
# Building our Artificial Neural Network
model_keras <- keras_model_sequential()

model_keras %>% 
  
  # First hidden layer
  layer_dense(
    units              = 16, #神经元的个数
    kernel_initializer = "uniform", 
    activation         = "relu", 
    input_shape        = ncol(x_train_tbl)) %>% 
  
  # Dropout to prevent overfitting
  layer_dropout(rate = 0.1) %>%
  
  # Second hidden layer
  layer_dense(
    units              = 16, 
    kernel_initializer = "uniform", 
    activation         = "relu") %>% 
  
  # Dropout to prevent overfitting
  layer_dropout(rate = 0.1) %>%
  
  # Output layer
  layer_dense(
    units              = 1, 
    kernel_initializer = "uniform", 
    activation         = "sigmoid") %>% 
  
  # Compile ANN
  compile(
    optimizer = 'adam',
    loss      = 'binary_crossentropy',
    metrics   = c('accuracy')
  )

keras_model
``` 
#### Fit Model

We use the fit() function to run the ANN on our training data. The object is our model, and x and y are our training data in matrix and numeric vector forms, respectively. The `batch_size = 50` sets the number samples per gradient update within each epoch. We set `epochs = 35` to control the number training cycles. Typically we want to keep the batch size high since this decreases the error within each training cycle (epoch). We also want epochs to be large, which is important in visualizing the training history (discussed below). We set `validation_split = 0.30` to include 30% of the data for model validation, which prevents overfitting. The training process should complete in 15 seconds or so.

我们将" validation_split = 0.30"设置为包括30％的数据用于模型验证，这可以防止过拟合。
验证集弄大一点可以防止模型过拟合??

```{r}
# Fit the keras model to the training data
history <- fit(
  object           = model_keras, 
  x                = as.matrix(x_train_tbl), 
  y                = y_train_vec,
  batch_size       = 50, 
  epochs           = 35,
  validation_split = 0.30
)
```

#### vis history

We can inspect the training history. We want to make sure there is minimal difference between the validation accuracy and the training accuracy.
    
```{r}
# Print a summary of the training history
print(history)

```

We can visualize the Keras training history using the `plot()` function. What we want to see is the validation accuracy and loss leveling off, which means the model has completed training. We see that there is some divergence between training loss/accuracy and validation loss/accuracy. This model indicates we can possibly stop training at an earlier epoch. <font color="darkred">**Pro Tip: Only use enough epochs to get a high validation accuracy. Once validation accuracy curve begins to flatten or decrease, it's time to stop training.**</font> 
    

> 专家提示：请仅使用足够的 epochs 以获得较高的验证准确性。验证准确性曲线开始变平或减小后，就该停止训练了。

```{r}

# Plot the training/validation history of our Keras model
plot(history) +
    theme_tq() +
    scale_color_tq() +
    scale_fill_tq() +
    labs(title = "Deep Learning Training Results")
```

### Making Predictions

We've got a good model based on the validation accuracy. Now let's make some predictions from our [keras](https://tensorflow.rstudio.com/keras/) model on the test data set, which was unseen during modeling (we use this for the true performance assessment). We have two functions to generate predictions:

  * `predict_classes()`: Generates class values as a matrix of ones and zeros. Since we are dealing with binary classification, we'll convert the output to a vector.
  * `predict_proba()`: Generates the class probabilities as a numeric matrix indicating __the probability of being a class__. Again, we convert to a numeric vector because there is only one column output.


```{r}
# test_tbl  <- testing(train_test_split) # raw dataset dataframe
# x_test_tbl  <- bake(rec_obj, new_data = test_tbl) %>% select(-Churn) # machine learning dataset

# Predicted Class
yhat_keras_class_vec <-
  predict_classes(object = model_keras, x = as.matrix(x_test_tbl)) %>%
  as.vector()

# Predicted Class Probability
yhat_keras_prob_vec  <-
  predict_proba(object = model_keras, x = as.matrix(x_test_tbl)) %>%
  as.vector()
```


## Inspect Performance With Yardstick

The `yardstick` package has a collection of handy functions for measuring performance of machine learning models. We'll overview some metrics we can use to understand the performance of our model.

First, let's get the data formatted for `yardstick`. We create a data frame with the __truth (actual values as factors)__, __estimate (predicted values as factors)__, and __the class probability (probability of yes as numeric)__. We use the `fct_recode()` function from the [forcats](http://forcats.tidyverse.org/) package to assist with recoding as Yes/No values.

```{r}
# Format test data and predictions for yardstick metrics
estimates_keras_tbl <- tibble(
  truth      = as.factor(y_test_vec) %>% fct_recode(yes = "1", no = "0"),
  estimate   = as.factor(yhat_keras_class_vec) %>% fct_recode(yes = "1", no = "0"),
  class_prob = yhat_keras_prob_vec
)

estimates_keras_tbl
```


Now that we have the data formatted, we can take advantage of the `yardstick` package. The only other thing we need to do is to set `options(yardstick.event_first = FALSE)`. As pointed out by [ad1729](https://github.com/ad1729) in [GitHub Issue 13](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/options(yardstick.event_first%20=%20FALSE)), the default is to classify 0 as the positive class instead of 1.

这个问题在最新版的 yardstick 已经得到解决了

```{r}
#options(yardstick.event_first = FALSE)
```

#### Confusion Table

We can use the `conf_mat()` function to get the confusion table. We see that the model was by no means perfect, but it did a decent job of identifying customers likely to churn.
    
```{r}
# Confusion Table
estimates_keras_tbl %>% conf_mat(truth, estimate)

```

#### Accuracy

We can use the `metrics()` function to get an accuracy measurement from the test set. We are getting roughly 82% accuracy.

```{r}
# Accuracy
estimates_keras_tbl %>% yardstick::accuracy(truth, estimate)

```

#### AUC

We can also get the ROC Area Under the Curve (AUC) measurement. AUC is often a good metric used to compare different classifiers and to compare to randomly guessing (AUC_random = 0.50). Our model has AUC = 0.85, which is much better than randomly guessing. Tuning and testing different classification algorithms may yield even better results.
    
```{r}
estimates_keras_tbl %>% yardstick::roc_auc(truth, class_prob)

```


#### Precision And Recall

Precision is when the model predicts "yes", how often is it actually "yes". Recall (also true positive rate or specificity) is when the actual value is "yes" how often is the model correct. We can get `precision()` and `recall()` measurements using `yardstick`.
    
```{r}
# Precision
tibble(
  precision = estimates_keras_tbl %>% yardstick::precision(truth, estimate),
  recall    = estimates_keras_tbl %>% yardstick::recall(truth, estimate)
)
```

Precision and recall are very important to the business case: The organization is concerned with **balancing the cost of targeting and retaining customers at risk of leaving with the cost of inadvertently targeting customers that are not planning to leave** (and potentially decreasing revenue from this group). The threshold above which to predict Churn = "Yes" can be adjusted to optimize for the business problem. This becomes an **Customer Lifetime Value optimization problem** that is discussed further in [Next Steps](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/#next-steps).

  
#### F1 Score

We can also get the F1-score, which is a __weighted average between the precision and recall.__ Machine learning classifier thresholds are often adjusted to maximize the F1-score. However, this is often not the optimal solution to the business problem.
    
```{r}
# F1-Statistic
estimates_keras_tbl %>% yardstick::f_meas(truth, estimate)

```


## 📌 Explain The Model With LIME

LIME stands for _Local Interpretable Model-agnostic Explanations_, and is a method for explaining black-box machine learning model classifiers. For those new to LIME, this YouTube video does a really nice job explaining how LIME helps to identify feature importance with black box machine learning models (e.g. deep learning, stacked ensembles, random forest).

![why should I trust you](https://i.loli.net/2020/04/18/5QsLvq1PdHUthGC.png)

[(28) KDD2016 paper 573 - YouTube](https://www.youtube.com/watch?v=hUnRCxnydCc&feature=emb_logo)

#### Setup

The [lime](https://github.com/thomasp85/lime) package implements [LIME](https://github.com/marcotcr/lime) in R. One thing to note is that it's not setup out-of-the-box to work with `keras`. The good news is with a few functions we can get everything working properly. We'll need to make two custom functions:

  * `model_type`: Used to tell `lime` __what type of model we are dealing with__. It could be classification, regression, survival, etc.

  * `predict_model`: Used to allow `lime` to perform predictions that its algorithm can interpret.

##### model_type fucntion define

The first thing we need to do is __identify the class of our model object__. We do this with the `class()` function.

```{r}
class(model_keras)
```

Next we create our `model_type()` function. It's only input is x the keras model. __The function simply returns "classification", which tells LIME we are classifying.__

```{r}
# Setup lime::model_type() function for keras
# gives error

# model_type.keras.models.Sequential <- function(x, ...) {
#   "classification"
# }

# works!
model_type.keras.engine.sequential.Sequential <-
  function(x, ...) {
    "classification"
  }
    
```
##### predict_model function define

Now we can create our `predict_model()` function, which wraps `keras::predict_proba()`. __The trick here is to realize that it's inputs must be x a model, newdata a dataframe object (this is important)__, and type which is not used but can be use to switch the output type. The output is also a little tricky because it must be in the format of probabilities by classification (this is important; shown next).

```{r}
# Setup lime::predict_model() function for keras

# gives error
# predict_model.keras.models.Sequential <- function(x, newdata, type, ...) {
#   pred <- predict_proba(object = x, x = as.matrix(newdata))
#   data.frame(Yes = pred, No = 1 - pred)
# }

# works!
predict_model.keras.engine.sequential.Sequential <- function(x, newdata, type, ...) {
  pred <- predict_proba(object = x, x = as.matrix(newdata))
  data.frame(Yes = pred, No = 1 - pred)
}
```

Run this next script to show you what the output looks like and to test our predict_model() function. See how it's the probabilities by classification. It must be in this form for `model_type = "classification"`.

##### predict_model() function
```{r}
# Test our predict_model() function
predict_model(x = model_keras, newdata = x_test_tbl, type = 'raw') %>%
  tibble::as_tibble()
```

#### Enjoy LIME
Now the fun part, we create an explainer using the `lime()` function. Just pass the training data set without the "Attribution column". The form must be a data frame, which is OK since our `predict_model` function will switch it to an keras object. Set `model = automl_leader` our leader model, and `bin_continuous = FALSE`. We could tell the algorithm to bin continuous variables, but this may not make sense for categorical numeric data that we didn't change to factors.


```{r}
# Run lime() on training set
explainer <- lime::lime(
  x              = x_train_tbl, 
  model          = model_keras, 
  bin_continuous = FALSE
)
```

Now we run the `explain()` function, which returns our explanation. This can take a minute to run so we limit it to just the first ten rows of the test data set. 

+ We set `n_labels = 1` because we care about explaining a single class.
+ Setting `n_features = 4` __returns the top four features that are critical to each case__. 
+ Finally, setting `kernel_width = 0.5` allows us to increase the "model_r2" value by shrinking the localized evaluation.

```{r}
# Run explain() on explainer
explanation <- lime::explain(
  x_test_tbl[1:10, ], 
  explainer    = explainer, 
  n_labels     = 1, 
  n_features   = 4,
  kernel_width = 0.5
)
```

#### Feature Importance Visualization

The payoff for the work we put in using LIME is this **feature importance plot**. This allows us to visualize each of the first ten cases (observations) from the test data. __The top four features for each case are shown__. Note that __they are not the same for each case__. 

The green bars mean that the feature __supports the model conclusion__, and the red bars contradict. 

A few important features based on frequency in first ten cases:

  * Tenure (7 cases)
  * Senior Citizen (5 cases)
  * Online Security (4 cases)

```{r}
plot_features(explanation) +
  labs(title = "LIME Feature Importance Visualization",
       subtitle = "Hold Out (Test) Set, First 10 Cases Shown")
```



Another excellent visualization can be performed using `plot_explanations()`, which produces a facetted heatmap of all case/label/feature combinations. It's a more condensed version of plot_features(), but we need to be careful because it does not provide exact statistics and it makes it less easy to investigate binned features (Notice that "tenure" would not be identified as a contributor even though it shows up as a top feature in 7 of 10 cases).

```{r}
plot_explanations(explanation) +
    labs(title = "LIME Feature Importance Heatmap",
         subtitle = "Hold Out (Test) Set, First 10 Cases Shown")
```

## 📌 Check Explanations With Correlation Analysis

One thing we need to be careful with the LIME visualization is that we are only doing a sample of the data, in our case the first 10 test observations. Therefore, we are __gaining a very localized understanding of how the ANN works__. However, we also want to know on from a global perspective what drives feature importance.

We can perform a **correlation analysis** on the training set as well to help glean what features correlate globally to "Churn". We'll use the `corrr` package, which performs tidy correlations with the function `correlate()`. We can get the correlations as follows.

```{r}
# Feature correlations to Churn
corrr_analysis <- x_train_tbl %>%
  mutate(Churn = y_train_vec) %>%
  correlate() %>%
  focus(Churn) %>%
  rename(feature = rowname) %>%
  arrange(abs(Churn)) %>%
  mutate(feature = as_factor(feature)) 
corrr_analysis
```



The correlation visualization helps in distinguishing which features are relavant to Churn.

```{r}
# Correlation visualization
corrr_analysis %>%
  ggplot(aes(x = Churn, y = fct_reorder(feature, desc(Churn)))) +
  geom_point() +
  # Positive Correlations - Contribute to churn
  geom_segment(aes(xend = 0, yend = feature), 
               color = palette_light()[[2]], 
               data = corrr_analysis %>% filter(Churn > 0)) +
  geom_point(color = palette_light()[[2]], 
             data = corrr_analysis %>% filter(Churn > 0)) +
  # Negative Correlations - Prevent churn
  geom_segment(aes(xend = 0, yend = feature), 
               color = palette_light()[[1]], 
               data = corrr_analysis %>% filter(Churn < 0)) +
  geom_point(color = palette_light()[[1]], 
             data = corrr_analysis %>% filter(Churn < 0)) +
  # Vertical lines
  geom_vline(xintercept = 0, color = palette_light()[[5]], size = 1, linetype = 2) +
  geom_vline(xintercept = -0.25, color = palette_light()[[5]], size = 1, linetype = 2) +
  geom_vline(xintercept = 0.25, color = palette_light()[[5]], size = 1, linetype = 2) +
  # Aesthetics
  theme_tq() +
  labs(title = "Churn Correlation Analysis",
       subtitle = paste("Positive Correlations (contribute to churn),", "Negative Correlations (prevent churn)"), 
       y = "Feature Importance")
```


The correlation analysis helps us quickly disseminate which features that the LIME analysis may be excluding. We can see that the following features are highly correlated (magnitude > 0.25):

+ Increases Likelihood of Churn (Red): - Tenure = Bin 1 (<12 Months) - Internet Service = "Fiber Optic" - Payment Method = "Electronic Check"


+ Decreases Likelihood of Churn (Blue): - Contract = "Two Year" - Total Charges (Note that this may be a biproduct of additional services such as Online Security)



## 📌  Feature Investigation

We can investigate features that are **most frequent** in the LIME feature importance visualization along with those that the **correlation analysis shows an above normal magnitude**. We'll investigate:

  * Tenure (7/10 LIME Cases, Highly Correlated)
  * Contract (Highly Correlated)
  * Internet Service (Highly Correlated)
  * Payment Method (Highly Correlated)
  * Senior Citizen (5/10 LIME Cases)
  * Online Security (4/10 LIME Cases)

#### Tenure (7/10 LIME Cases, Highly Correlated)

LIME cases indicate that the ANN model is using this feature frequently and high correlation agrees that this is important. Investigating the feature distribution, it appears that customers with lower tenure (bin 1) are more likely to leave. **Opportunity: Target customers with less than 12 month tenure.**

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-45-1.png)

#### Contract (Highly Correlated)

While LIME did not indicate this as a primary feature in the first 10 cases, the feature is clearly correlated with those electing to stay. Customers with one and two year contracts are much less likely to churn. **Opportunity: Offer promotion to switch to long term contracts.**

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-46-1.png)

#### Internet Service (Highly Correlated)

While LIME did not indicate this as a primary feature in the first 10 cases, the feature is clearly correlated with those electing to stay. Customers with fiber optic service are more likely to churn while those with no internet service are less likely to churn. **Improvement Area: Customers may be dissatisfied with fiber optic service.**

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-47-1.png)

#### Payment Method (Highly Correlated)

While LIME did not indicate this as a primary feature in the first 10 cases, the feature is clearly correlated with those electing to stay. Customers with electronic check are more likely to leave. **Opportunity: Offer customers a promotion to switch to automatic payments**.

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-48-1.png)

#### Senior Citizen (5/10 LIME Cases)

Senior citizen appeared in several of the LIME cases indicating it was important to the ANN for the 10 samples. However, it was not highly correlated to Churn, which may indicate that the ANN is using in an more sophisticated manner (e.g. as an interaction). It's difficult to say that senior citizens are more likely to leave, but non-senior citizens appear less at risk of churning. **Opportunity: Target users in the lower age demographic.**

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-49-1.png)

#### Online Security (4/10 LIME Cases)

Customers that did not sign up for online security were more likely to leave while customers with no internet service or online security were less likely to leave. **Opportunity: Promote online security and other packages that increase retention rates.**

![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/figure-html/unnamed-chunk-50-1.png)

## 📌 Next Steps: Business Science University(Domain knowledge)

We've just scratched the surface with the solution to this problem, but unfortunately there's only so much ground we can cover in an article. Here are a few next steps that I'm pleased to announce will be covered in a [**Business Science University**](https://university.business-science.io/) course coming in 2018!

### Customer Lifetime Value

**Your organization needs to see the financial benefit so always tie your analysis to sales, profitability or ROI.** [Customer Lifetime Value (_CLV_)](https://en.wikipedia.org/wiki/Customer_lifetime_value) is a methodology that ties the business profitability to the retention rate. While we did not implement the CLV methodology herein, a full customer churn analysis would tie the churn to an classification cutoff (threshold) optimization to maximize the CLV with the predictive ANN model.

The simplified CLV model is:

CLV=GC∗11+d−rCLV=GC∗11+d−r

Where,

  * _GC_ is the gross contribution per customer
  * _d_ is the annual discount rate
  * _r_ is the retention rate

### ANN Performance Evaluation and Improvement

The ANN model we built is good, but it could be better. How we understand our model accuracy and improve on it is through the combination of two techniques:

  * **K-Fold Cross-Fold Validation**: Used to obtain bounds for accuracy estimates.
  * **Hyper Parameter Tuning**: Used to improve model performance by searching for the best parameters possible.

We need to implement _K-Fold Cross Validation_ and _Hyper Parameter Tuning_ if we want a best-in-class model.

### Distributing Analytics

**It's critical to communicate data science insights to decision makers in the organization**. Most decision makers in organizations are not data scientists, but these individuals make important decisions on a day-to-day basis. The Shiny application below includes a **Customer Scorecard** to monitor customer health (risk of churn).

[![](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/images/shiny-application.png)](https://jjallaire.shinyapps.io/keras-customer-churn/)

### Business Science University

You're probably wondering why we are going into so much detail on next steps. We are happy to announce a new project for 2018: [**Business Science University**](https://university.business-science.io/), an online school dedicated to helping data science learners.

Benefits to learners:

  * Build your own **online GitHub portfolio** of data science projects to market your skills to future employers!
  * Learn **real-world applications** in People Analytics (HR), Customer Analytics, Marketing Analytics, Social Media Analytics, Text Mining and Natural Language Processing (NLP), Financial and Time Series Analytics, and more!
  * Use **advanced machine learning techniques** for both high accuracy modeling and explaining features that have an effect on the outcome!
  * Create **ML-powered web-applications** that can be distributed throughout an organization, enabling non-data scientists to benefit from algorithms in a user-friendly way!

**Enrollment is open** so please signup for special perks. Just go to [**Business Science University**](https://university.business-science.io/) and select enroll.

## Conclusions

**Customer churn is a costly problem**. The good news is that **machine learning can solve churn problems**, making the organization more profitable in the process. In this article, we saw how **Deep Learning can be used to predict customer churn**. We built an ANN model using the new [keras](https://tensorflow.rstudio.com/keras/) package that achieved **82% predictive accuracy** (without tuning)! We used three new machine learning packages to help with preprocessing and measuring performance: [recipes](https://topepo.github.io/recipes), [rsample](https://topepo.github.io/rsample/) and [yardstick](https://github.com/topepo/yardstick). Finally we used [lime](https://github.com/thomasp85/lime) to explain the Deep Learning model, which **traditionally was impossible**! We checked the LIME results with a **Correlation Analysis**, which brought to light other features to investigate. For the IBM Telco dataset, tenure, contract type, internet service type, payment menthod, senior citizen status, and online security status were useful in diagnosing customer churn. We hope you enjoyed this article!

## Links

+ [RStudio AI Blog: Deep Learning With Keras To Predict Customer Churn](https://blogs.rstudio.com/tensorflow/posts/2018-01-11-keras-customer-churn/)

+ [Machine_Learning_projects/churn_analysis.Rmd at 6d3814a596bc2f9dee09fffbf45a8e052dcefc09 · bennwei/Machine_Learning_projects](https://github.com/bennwei/Machine_Learning_projects/blob/6d3814a596bc2f9dee09fffbf45a8e052dcefc09/Churn_analysis_R/churn_analysis.Rmd)

## Error

"Error in `dimnames<-.data.frame`(`*tmp*`, value = list(n)) :   invalid 'dimnames' given for data frame"

[keras explanations with dataframe data · Issue #139 · thomasp85/lime](https://github.com/thomasp85/lime/issues/139)

I had the same error, and I managed to solve it by overwriting the correct output of class(model). It seems the newer version uses different name. So, it is fixed for by:
    
    class(model_keras)
    # [1] "keras.engine.sequential.Sequential"
    # [2] "keras.engine.training.Model"       
    # [3] "keras.engine.network.Network"      
    # [4] "keras.engine.base_layer.Layer"     
    # [5] "python.builtin.object"    
    

Then use `keras.engine.sequential.Sequential` instead of `keras.models.Sequential`, i.e.:
    
    # gives error
    model_type.keras.models.Sequential <- function(x, ...) {
      "classification"
    }
    
    # works!
    model_type.keras.engine.sequential.Sequential <- function(x, ...) {
      "classification"
    }
    
    

The same for `predict_model()`, use `keras.engine.sequential.Sequential`, or what is the output of `class(model)`

